{"version":3,"sources":["utils.ts","render.ts","generator.ts","solver.ts","canvas.tsx","App.tsx","index.tsx"],"names":["Direction","render","context","board","blockWidth","blockHeight","draw","block","color","sizeOffset","offset","fillStyle","fillRect","pos","x","y","forEach","col","e","start","end","next","onPath","solved","visited","topLeft","botLeft","topRight","botRight","drawLine","beginPath","moveTo","lineTo","strokeStyle","stroke","bottomWall","leftWall","rightWall","topWall","drawWalls","lines","pred","predPos","drawConnecting","neighbours","cols","rows","solving","row","all","push","length","filter","determineDir","first","second","rowDif","colDif","Down","Up","Right","Left","findStartOrEnd","found","b","randomizeStartAndEnd","availableSpots","filtered","c","filterEdges","cell","Math","floor","random","generator","path","current","undefined","window","requestAnimationFrame","step","neighbors","dir","breakWall","pop","clearRect","width","height","solver","correctPath","shift","console","log","cPath","generateCorrectPath","r","n","available","filterAvailable","innerWidth","innerHeight","Canvas","canvasRef","useRef","useState","setRows","setCols","setBlockWidth","setBlockHeight","randomizedLocations","setRandomizedLocations","rerollCount","increaseRerollCount","useEffect","getContext","temp","initalize","className","onClick","generate","solve","setLines","id","type","min","onChange","event","Number","target","value","htmlFor","ref","App","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.2c409b56.chunk.js","sourcesContent":["import render, { Block, } from \"./render\"\r\n\r\nexport enum Direction {\r\n    Up = 1,\r\n    Down,\r\n    Left,\r\n    Right,\r\n}   \r\n\r\nconst neighbours = (board:Block[][],block:Block,cols:number,rows:number, solving?:boolean):Block[] => {\r\n    const row = block.row\r\n    const col = block.col\r\n    let all:Block[] = []\r\n    if (row > 0 ) all.push(board[col][row -1])\r\n    if (col > 0 ) all.push(board[col -1][row])\r\n    if (row < rows -1) all.push(board[col][row +1])\r\n    if (col < cols -1) all.push(board[col+1][row])\r\n    if (all.length === 0) return []\r\n    else {\r\n        const filtered = all.filter(x=>solving? !x.solved: !x.visited)\r\n        return filtered\r\n    }\r\n}\r\n\r\n\r\n\r\n//determines the direction of the second block in relation of the first block\r\nconst determineDir = (first:Block, second:Block) => {\r\n    \r\n    const rowDif = first.row - second.row\r\n    const colDif = first.col - second.col\r\n\r\n    if (rowDif < 0)  return Direction.Down \r\n    if (rowDif > 0)  return Direction.Up\r\n    if (colDif < 0)  return Direction.Right\r\n    if (colDif > 0)  return Direction.Left\r\n\r\n   \r\n}\r\n\r\nconst filterAvailable = (current:Block, neighbours: Block[]) => {\r\n    return neighbours.filter(b => {\r\n        const directionFromCurrent = determineDir(current, b)\r\n        switch (directionFromCurrent) {\r\n            case Direction.Up:\r\n                return !(current.topWall && b.bottomWall)\r\n            case Direction.Down:\r\n                return !(current.bottomWall && b.topWall)\r\n            case Direction.Left:\r\n                return !(current.leftWall && b.rightWall)\r\n            case Direction.Right:\r\n                return !(current.rightWall && b.leftWall)\r\n        }\r\n        return false\r\n    })\r\n}\r\n\r\nconst generateCorrectPath = (context:CanvasRenderingContext2D,board: Block[][],cPath:Block[], blockWidth:number, blockHeight: number) => {\r\n    const start = findStartOrEnd(board, true)\r\n    const end = findStartOrEnd(board, false)\r\n    if (!(start)) {\r\n        return //start and end should always exist\r\n    }\r\n    if (!end) {\r\n        return\r\n    }\r\n    cPath = [];\r\n    let current = end;\r\n    const step = () =>  {\r\n        if (current.pred) {\r\n            window.requestAnimationFrame(step)\r\n            cPath.push(current);\r\n            current.onPath = true\r\n            current = current.pred;\r\n        }\r\n        render(context, board, blockWidth, blockHeight);\r\n     \r\n    }\r\n   \r\n    cPath.push(start);\r\n    start.onPath = true\r\n    window.requestAnimationFrame(step)\r\n    \r\n  };\r\n\r\n  const findStartOrEnd = (board: Block[][], start:boolean): Block | undefined => {\r\n    let found: Block |undefined  \r\n    board.forEach(e => {\r\n        e.forEach(b => {\r\n            if (start ? b.start : b.end) {\r\n                found = b\r\n                return\r\n            }\r\n        })\r\n    })\r\n    return found\r\n  }\r\n\r\n  const filterEdges = (board: Block[][], cols: number, rows:number) => {\r\n      const filtered:Block[] = []\r\n      board.forEach(c => {\r\n          c.forEach(b => {\r\n              if (b.row === 0 || b.row === rows-1 || b.col === 0 || b.col === cols-1) {\r\n                  filtered.push(b)\r\n              }\r\n          })\r\n      })\r\n      return filtered\r\n  }\r\n\r\n  const randomizeStartAndEnd = (board:Block[][], cols:number, rows: number, start:boolean) => {\r\n        const availableSpots = filterEdges(board,cols,rows)\r\n        \r\n        \r\n      \r\n        const cell = availableSpots[Math.floor(Math.random() * availableSpots.length)] //pick one randomly\r\n        start ? cell.start = true : cell.end=true\r\n        if (start) cell.visited = true\r\n  }\r\n\r\nexport {neighbours, determineDir, filterAvailable, generateCorrectPath, findStartOrEnd, randomizeStartAndEnd}","\nimport {lines} from \"./canvas\"\n\n\nexport type Coord = {\n    x: number\n    y: number\n}\n\n\n\nexport type Block = {\n    leftWall:boolean\n    topWall: boolean\n    rightWall:boolean\n    bottomWall:boolean\n    pos: Coord\n    visited:boolean\n    row:number\n    col:number\n    next: boolean\n    pred: Block | undefined\n    start:boolean\n    end:boolean\n    solved:boolean\n    onPath: boolean\n}\n\n\n\nconst render = (context:CanvasRenderingContext2D, board: Block[][], blockWidth:number, blockHeight:number) => {\n  \n    \n    const draw = (block:Block, color:string,sizeOffset?:number) => {\n        const offset = sizeOffset ?sizeOffset : 0\n        context.fillStyle= color\n        context.fillRect(block.pos.x,block.pos.y,blockWidth- offset,blockHeight- offset)\n        \n    }\n\n    \n    \n    \n\n    const drawWalls = (block:Block) => {\n\n        const topLeft  = {x:block.pos.x, y:block.pos.y}\n        const botLeft  = {x:block.pos.x, y:block.pos.y + blockHeight}\n        const topRight = {x:block.pos.x + blockWidth, y:block.pos.y}\n        const botRight = {x:block.pos.x + blockWidth, y:block.pos.y + blockHeight}\n        \n\n        const drawLine = (start:Coord,end:Coord) => {\n            context.beginPath()\n            context.moveTo(start.x,start.y)\n            context.lineTo(end.x,end.y)\n            context.strokeStyle = \"black\"\n            context.stroke()\n        }\n        \n        if (block.bottomWall) drawLine(botLeft, botRight)\n        if (block.leftWall)   drawLine(topLeft, botLeft)\n        if (block.rightWall)  drawLine(topRight,botRight)\n        if (block.topWall)    drawLine(topLeft, topRight)\n       \n    }\n\n    \n\n    const drawConnecting = (block: Block) => {\n        const pos:Coord = {x: block.pos.x + blockWidth / 2, y:block.pos.y+blockHeight /2}\n        if (block.pred) {\n            const predPos:Coord = {x:block.pred.pos.x + blockWidth /2, y:block.pred.pos.y + blockHeight / 2}\n            context.beginPath()\n            context.strokeStyle = \"green\"\n            context.moveTo(pos.x,pos.y)\n            context.lineTo(predPos.x,predPos.y)\n            context.stroke()\n        }\n    }\n\n\n    board.forEach(col => col.forEach(e =>{\n        if(e.start) draw(e,\"orange\")\n        else if (e.end) draw(e, \"#04fca4\")\n        else if (e.next) draw(e,\"blue\")\n        else if (e.onPath) draw(e, \"#85bbb6\")\n        else if(e.solved) draw(e, \"#8abb85\")\n        else if(e.visited) draw(e,\"white\")\n        else draw(e,\"#b678bd\") \n        drawWalls(e)\n        if (lines) drawConnecting(e)\n        \n    } ) )\n    \n}\n\nexport default render","import { Block } from \"./render\"\nimport {  height, width } from \"./canvas\"\nimport {neighbours, determineDir, Direction, findStartOrEnd} from \"./utils\"\nimport render from \"./render\"\n\n\n\n\n\n\n\nconst generator = (context:CanvasRenderingContext2D, board:Block[][],  cols:number, rows:number, blockWidth:number, blockHeight: number) => {\n    const start  =findStartOrEnd(board,true)\n    if (!start) {\n        return // startingpoint should always exist\n    }\n    const path:Block[]  = [start]\n\nconst breakWall = (start: Block,end:Block) => {\n\n    const dir = determineDir(start,end)\n    if (dir === Direction.Up) {\n        start.topWall = false\n        end.bottomWall = false\n    }\n\n    if (dir === Direction.Down) {\n        start.bottomWall = false\n        end.topWall      = false \n    }\n\n    if (dir === Direction.Left) {\n        start.leftWall = false\n        end.rightWall = false\n    }\n\n    if (dir === Direction.Right) {\n        start.rightWall = false\n        end.leftWall = false\n    }\n    \n}\n\n  \n  let current:Block | undefined = start\n  let next:Block | undefined  = undefined\n\n/**\n * step is a single step of depth-first search algorithm,\n * which is rendered on a canvas\n */\n\n  const step = () => { \n\n  if (path.length) {\n    window.requestAnimationFrame(step)\n    if (!current) return\n    current.next = false\n    current.visited = true\n    const neighbors = neighbours(board,current,cols, rows)\n    if (neighbors.length) {\n        next= neighbors[Math.floor(Math.random()*neighbors.length)]; //pick a random next neighbor\n        next.pred = current\n        next.next = true\n         breakWall(current,next)\n         path.push(current = next)\n    }\n\n    else {\n            current = path.pop()\n    }\n\n  }\n  context.clearRect(0,0,width,height)\n  render(context,board,blockWidth, blockHeight)\n  }\n  \nwindow.requestAnimationFrame(step)\n}\n\nexport default generator","\r\n\r\nimport { height, width } from \"./canvas\"\r\nimport render, { Block } from \"./render\"\r\nimport { neighbours, filterAvailable, generateCorrectPath, findStartOrEnd } from \"./utils\"\r\n\r\n\r\nconst solver = (context:CanvasRenderingContext2D,board: Block[][],correctPath: Block[],cols:number, rows:number, blockWidth:number, blockHeight: number) => {\r\n    const start = findStartOrEnd(board, true)\r\n    if (!start) {\r\n        return\r\n    }\r\n    const path:Block[]  = [start] //start from the first block - set start\r\n    let found = false\r\n\r\n    const step = () => { \r\n        if (path.length) {\r\n\r\n            if (!found) {\r\n\r\n                window.requestAnimationFrame(step)\r\n            }\r\n            const current = path.shift()\r\n            console.log(current)\r\n            if (!current) {\r\n                return false\r\n            }\r\n            current.solved = true\r\n            if (current.end) {\r\n                found = true\r\n                generateCorrectPath(context, board, correctPath, blockWidth, blockHeight)\r\n                board.forEach(e => e.forEach(r => r.solved = false))\r\n                return current\r\n            }\r\n            console.log(board)\r\n            const n = neighbours(board, current,cols,rows, true)\r\n            console.log(n)\r\n            const available = filterAvailable(current,n)\r\n            console.log(available)\r\n            available.forEach(e => {\r\n                if (!e.solved) {\r\n                    path.push(e)\r\n                }\r\n            })\r\n        }\r\n        \r\n        context.clearRect(0,0,width,height)\r\n        render(context,board,blockWidth, blockHeight)\r\n        }\r\n        \r\n      window.requestAnimationFrame(step)\r\n      \r\n      \r\n      }\r\n\r\n\r\n\r\nexport  {solver}","import React, { useRef, useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport render, { Block } from \"./render\";\nimport generator from \"./generator\";\nimport { solver } from \"./solver\";\nimport { randomizeStartAndEnd } from \"./utils\";\n\nexport const width = window.innerWidth * 0.8;\nexport const height = window.innerHeight * 0.8;\n\nexport let lines = false;\n\nconst Canvas = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [rows, setRows] = useState(20);\n  const [cols, setCols] = useState(40);\n  const [blockWidth, setBlockWidth] = useState(width / cols);\n  const [blockHeight, setBlockHeight] = useState(height / rows);\n  const [randomizedLocations, setRandomizedLocations] = useState(false);\n  const [rerollCount, increaseRerollCount] = useState(0);\n\n  let cPath: Block[] = [];\n  let board: Block[][] = [];\n  let generating: boolean = false;\n\n  const generate = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    generator(context, board, cols, rows, blockWidth, blockHeight);\n  };\n\n  const solve = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    solver(context, board, cPath, cols, rows, blockWidth, blockHeight);\n  };\n\n  const setLines = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    lines = !lines;\n    render(context, board, blockWidth, blockHeight);\n  };\n\n  const initalize = (context: CanvasRenderingContext2D) => {\n    board = [];\n    context.clearRect(0, 0, width, height);\n\n    for (let col = 0; col < cols; col++) {\n      const temp: Block[] = [];\n      for (let row = 0; row < rows; row++)\n        temp.push({\n          leftWall: true,\n          topWall: true,\n          rightWall: true,\n          bottomWall: true,\n          pos: { x: col * blockWidth, y: row * blockHeight },\n          visited: false,\n          row: row,\n          col: col,\n          next: false,\n          pred: undefined,\n          start: false,\n          end: false,\n          solved: false,\n          onPath: false,\n        });\n      board.push(temp);\n    }\n    if (randomizedLocations) {\n      randomizeStartAndEnd(board, cols, rows, true); //pick random start\n      randomizeStartAndEnd(board, cols, rows, false); //pick random end\n    } else {\n      const start = board[0][0];\n      start.start = true;\n      start.visited = true;\n      const end = board[cols - 1][rows - 1];\n      end.end = true;\n    }\n\n    render(context, board, blockWidth, blockHeight);\n  };\n\n  const reroll = () => {\n    increaseRerollCount(rerollCount + 1);\n  };\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    initalize(context);\n  });\n\n  return (\n    <div className=\"canvasContainer\">\n      <div className=\"buttons\">\n        <button className=\"generator\" onClick={() => generate()}>\n          Generate Maze\n        </button>\n        <button className=\"solver\" onClick={() => solve()}>\n          Solve maze\n        </button>\n        <button className=\"lines\" onClick={() => setLines()}>\n          Show lines\n        </button>\n        <button onClick={() => setRandomizedLocations(!randomizedLocations)}>\n          {randomizedLocations\n            ? \"Set static locations\"\n            : \"Set randomized locations\"}\n        </button>\n        {randomizedLocations && (\n          <button onClick={() => reroll()}>Reroll</button>\n        )}\n        {randomizedLocations && (\n          <p>{`You have rerolled ${rerollCount} ${\n            rerollCount === 1 ? \"time\" : \"times\"\n          }`}</p>\n        )}\n      </div>\n      <div className=\"sliders\">\n        <input\n          id=\"colSlider\"\n          type=\"range\"\n          min={1}\n          onChange={(event) => {\n            setCols(Number(event.target.value));\n            setRows(rows);\n            setBlockHeight(height / rows);\n            setBlockWidth(width / cols);\n          }}\n          value={cols}\n          step={1}\n        ></input>\n        <label htmlFor=\"colSlider\">{`columns: ${cols}`}</label>\n        <input\n          id=\"rowSlider\"\n          type=\"range\"\n          min={1}\n          onChange={(event) => {\n            setRows(Number(event.target.value));\n            setCols(cols);\n            setBlockHeight(height / rows);\n            setBlockWidth(width / cols);\n          }}\n          value={rows}\n          step={1}\n        ></input>\n        <label htmlFor=\"rowSlider\">{`rows: ${rows}`}</label>\n      </div>\n      <div>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          width={width}\n          height={height}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Canvas;\n","import React from 'react';\nimport './App.css';\nimport Canvas from './canvas';\n\nconst App: React.FC = () => {\n\n \n\n  return (\n    <div className=\"container\">\n   <div>\n     <h1 className=\"header\">Maze Generator</h1>\n   </div >\n    <Canvas />\n   </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}