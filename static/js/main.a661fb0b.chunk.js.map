{"version":3,"sources":["utils.ts","render.ts","generator.ts","solver.ts","canvas.tsx","App.tsx","index.tsx"],"names":["Direction","render","context","board","correctPath","draw","block","color","sizeOffset","offset","fillStyle","fillRect","pos","x","y","blockWidth","blockHeight","forEach","col","e","start","end","next","onPath","solved","visited","topLeft","botLeft","topRight","botRight","drawLine","beginPath","moveTo","lineTo","strokeStyle","stroke","bottomWall","leftWall","rightWall","topWall","drawWalls","lines","pred","predPos","drawConnecting","neighbours","solving","row","all","push","rows","cols","length","filter","determineDir","first","second","rowDif","colDif","Down","Up","Right","Left","generator","path","current","undefined","window","requestAnimationFrame","step","neighbors","Math","floor","random","dir","breakWall","pop","clearRect","width","height","solver","found","shift","console","log","cPath","generateCorrectPath","r","n","available","b","filterAvailable","innerWidth","innerHeight","Canvas","canvasRef","useRef","initalize","temp","useEffect","getContext","className","onClick","generate","solve","setLines","ref","App","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.a661fb0b.chunk.js","sourcesContent":["import render, { Block, } from \"./render\"\r\nimport { rows, cols } from './canvas';\r\n\r\nexport enum Direction {\r\n    Up = 1,\r\n    Down,\r\n    Left,\r\n    Right,\r\n}   \r\n\r\nconst neighbours = (board:Block[][],block:Block, solving?:boolean):Block[] => {\r\n    const row = block.row\r\n    const col = block.col\r\n    let all:Block[] = []\r\n    if (row > 0 ) all.push(board[col][row -1])\r\n    if (col > 0 ) all.push(board[col -1][row])\r\n    if (row < rows -1) all.push(board[col][row +1])\r\n    if (col < cols -1) all.push(board[col+1][row])\r\n    if (all.length === 0) return []\r\n    else {\r\n        const filtered = all.filter(x=>solving? !x.solved: !x.visited)\r\n        return filtered\r\n    }\r\n}\r\n\r\n\r\n\r\n//determines the direction of the second block in relation of the first block\r\nconst determineDir = (first:Block, second:Block) => {\r\n    \r\n    const rowDif = first.row - second.row\r\n    const colDif = first.col - second.col\r\n\r\n    if (rowDif < 0)  return Direction.Down \r\n    if (rowDif > 0)  return Direction.Up\r\n    if (colDif < 0)  return Direction.Right\r\n    if (colDif > 0)  return Direction.Left\r\n\r\n   \r\n}\r\n\r\nconst filterAvailable = (current:Block, neighbours: Block[]) => {\r\n    return neighbours.filter(b => {\r\n        const directionFromCurrent = determineDir(current, b)\r\n        switch (directionFromCurrent) {\r\n            case Direction.Up:\r\n                return !(current.topWall && b.bottomWall)\r\n            case Direction.Down:\r\n                return !(current.bottomWall && b.topWall)\r\n            case Direction.Left:\r\n                return !(current.leftWall && b.rightWall)\r\n            case Direction.Right:\r\n                return !(current.rightWall && b.leftWall)\r\n        }\r\n        return false\r\n    })\r\n}\r\n\r\nconst generateCorrectPath = (context:CanvasRenderingContext2D,board: Block[][], cPath: Block[]) => {\r\n    \r\n    cPath = [];\r\n    let current = board[cols - 1][rows - 1];\r\n    const step = () =>  {\r\n        if (current.pred) {\r\n            window.requestAnimationFrame(step)\r\n            cPath.push(current);\r\n            current.onPath = true\r\n            current = current.pred;\r\n        }\r\n        render(context, board, cPath);\r\n     \r\n    }\r\n   \r\n    cPath.push(board[0][0]);\r\n    board[0][0].onPath = true\r\n    window.requestAnimationFrame(step)\r\n    \r\n  };\r\n\r\nexport {neighbours, determineDir, filterAvailable, generateCorrectPath}","\nimport {lines,blockHeight,blockWidth} from \"./canvas\"\n\n\nexport type Coord = {\n    x: number\n    y: number\n}\n\n\n\nexport type Block = {\n    leftWall:boolean\n    topWall: boolean\n    rightWall:boolean\n    bottomWall:boolean\n    pos: Coord\n    visited:boolean\n    row:number\n    col:number\n    next: boolean\n    pred: Block | undefined\n    start:boolean\n    end:boolean\n    solved:boolean\n    onPath: boolean\n}\n\n\n\nconst render = (context:CanvasRenderingContext2D, board: Block[][], correctPath:Block[]) => {\n  \n    \n    const draw = (block:Block, color:string,sizeOffset?:number) => {\n        const offset = sizeOffset ?sizeOffset : 0\n        context.fillStyle= color\n        context.fillRect(block.pos.x,block.pos.y,blockWidth- offset,blockHeight- offset)\n        \n    }\n\n    \n    \n    \n\n    const drawWalls = (block:Block) => {\n\n        const topLeft  = {x:block.pos.x, y:block.pos.y}\n        const botLeft  = {x:block.pos.x, y:block.pos.y + blockHeight}\n        const topRight = {x:block.pos.x + blockWidth, y:block.pos.y}\n        const botRight = {x:block.pos.x + blockWidth, y:block.pos.y + blockHeight}\n        \n\n        const drawLine = (start:Coord,end:Coord) => {\n            context.beginPath()\n            context.moveTo(start.x,start.y)\n            context.lineTo(end.x,end.y)\n            context.strokeStyle = \"black\"\n            context.stroke()\n        }\n        \n        if (block.bottomWall) drawLine(botLeft, botRight)\n        if (block.leftWall)   drawLine(topLeft, botLeft)\n        if (block.rightWall)  drawLine(topRight,botRight)\n        if (block.topWall)    drawLine(topLeft, topRight)\n       \n    }\n\n    \n\n    const drawConnecting = (block: Block) => {\n        const pos:Coord = {x: block.pos.x + blockWidth / 2, y:block.pos.y+blockHeight /2}\n        if (block.pred) {\n            const predPos:Coord = {x:block.pred.pos.x + blockWidth /2, y:block.pred.pos.y + blockHeight / 2}\n            context.beginPath()\n            context.strokeStyle = \"green\"\n            context.moveTo(pos.x,pos.y)\n            context.lineTo(predPos.x,predPos.y)\n            context.stroke()\n        }\n    }\n\n\n    board.forEach(col => col.forEach(e =>{\n        if(e.start || e.end) draw(e,\"orange\")\n        else if (e.next) draw(e,\"blue\")\n        else if (e.onPath) draw(e, \"#85bbb6\")\n        else if(e.solved) draw(e, \"#8abb85\")\n        else if(e.visited) draw(e,\"white\")\n        else draw(e,\"#b678bd\") \n        drawWalls(e)\n        if (lines) drawConnecting(e)\n        \n    } ) )\n    \n}\n\nexport default render","import { Block } from \"./render\"\nimport {  height, width } from \"./canvas\"\nimport {neighbours, determineDir, Direction} from \"./utils\"\nimport render from \"./render\"\n\n\n\n\n\n\nconst generator = (context:CanvasRenderingContext2D, board:Block[][], correctPath: Block[]) => {\n    const path:Block[]  = [board[0][0]]\n\nconst breakWall = (start: Block,end:Block) => {\n\n    const dir = determineDir(start,end)\n    if (dir === Direction.Up) {\n        start.topWall = false\n        end.bottomWall = false\n    }\n\n    if (dir === Direction.Down) {\n        start.bottomWall = false\n        end.topWall      = false \n    }\n\n    if (dir === Direction.Left) {\n        start.leftWall = false\n        end.rightWall = false\n    }\n\n    if (dir === Direction.Right) {\n        start.rightWall = false\n        end.leftWall = false\n    }\n    \n}\n\n  \n  let current:Block | undefined = board[0][0]\n  let next:Block | undefined  = undefined\n\n/**\n * step is a single step of depth-first search algorithm,\n * which is rendered on a canvas\n */\n\n  const step = () => { \n\n  if (path.length) {\n    window.requestAnimationFrame(step)\n    if (!current) return\n    current.next = false\n    current.visited = true\n    const neighbors = neighbours(board,current)\n    if (neighbors.length) {\n        next= neighbors[Math.floor(Math.random()*neighbors.length)]; //pick a random next neighbor\n        next.pred = current\n        next.next = true\n         breakWall(current,next)\n         path.push(current = next)\n    }\n\n    else {\n            current = path.pop()\n    }\n\n  }\n  context.clearRect(0,0,width,height)\n  render(context,board,correctPath)\n  }\n  \nwindow.requestAnimationFrame(step)\n}\n\nexport default generator","\r\nimport { height, width } from \"./canvas\"\r\nimport render, { Block } from \"./render\"\r\nimport { neighbours, filterAvailable, generateCorrectPath } from \"./utils\"\r\n\r\n\r\nconst solver = (context:CanvasRenderingContext2D,board: Block[][],correctPath: Block[]) => {\r\n    const path:Block[]  = [board[0][0]] //start from the first block - set start\r\n    let found = false\r\n\r\n    const step = () => { \r\n        if (path.length) {\r\n\r\n            if (!found) {\r\n\r\n                window.requestAnimationFrame(step)\r\n            }\r\n            const current = path.shift()\r\n            console.log(current)\r\n            if (!current) {\r\n                return false\r\n            }\r\n            current.solved = true\r\n            if (current.end) {\r\n                found = true\r\n                generateCorrectPath(context, board, correctPath)\r\n                board.forEach(e => e.forEach(r => r.solved = false))\r\n                return current\r\n            }\r\n            console.log(board)\r\n            const n = neighbours(board, current, true)\r\n            console.log(n)\r\n            const available = filterAvailable(current,n)\r\n            console.log(available)\r\n            available.forEach(e => {\r\n                if (!e.solved) {\r\n                    path.push(e)\r\n                }\r\n            })\r\n        }\r\n        \r\n        context.clearRect(0,0,width,height)\r\n        render(context,board,correctPath)\r\n        }\r\n        \r\n      window.requestAnimationFrame(step)\r\n      \r\n      \r\n      }\r\n\r\n\r\n\r\nexport  {solver}","import React, { useRef, useEffect } from \"react\";\nimport \"./App.css\";\nimport render, { Block } from \"./render\";\nimport generator from \"./generator\";\nimport { solver } from \"./solver\";\n\nexport const width = window.innerWidth * 0.8;\nexport const height = window.innerHeight * 0.8;\nexport const rows = 20;\nexport const cols = 40;\nexport const blockWidth = width / cols;\nexport const blockHeight = height / rows;\nexport let lines = false;\n\nconst Canvas = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  let cPath: Block[] = [];\n  let board: Block[][] = [];\n  let generating: boolean = false;\n  const generate = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    initalize(context);\n    generator(context, board, cPath);\n  };\n\n  const solve = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    solver(context, board, cPath);\n  };\n\n  const setLines = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    lines = !lines;\n    render(context, board, cPath);\n  };\n\n  const initalize = (context: CanvasRenderingContext2D) => {\n    board = [];\n    context.clearRect(0, 0, width, height);\n\n    for (let col = 0; col < cols; col++) {\n      const temp: Block[] = [];\n      for (let row = 0; row < rows; row++)\n        temp.push({\n          leftWall: true,\n          topWall: true,\n          rightWall: true,\n          bottomWall: true,\n          pos: { x: col * blockWidth, y: row * blockHeight },\n          visited: false,\n          row: row,\n          col: col,\n          next: false,\n          pred: undefined,\n          start: false,\n          end: false,\n          solved: false,\n          onPath: false,\n        });\n      board.push(temp);\n    }\n    const start = board[0][0];\n    start.start = true;\n    start.topWall = false;\n    start.visited = true;\n    board[cols - 1][rows - 1].end = true;\n    board[cols - 1][rows - 1].bottomWall = false;\n    render(context, board, cPath);\n  };\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    initalize(context);\n  });\n\n  return (\n    <div className=\"canvasContainer\">\n      <div className=\"buttons\">\n        <button className=\"generator\" onClick={() => generate()}>\n          Generate Maze\n        </button>\n        <button className=\"solver\" onClick={() => solve()}>\n          Solve maze\n        </button>\n        <button className=\"lines\" onClick={() => setLines()}>\n          Show lines\n        </button>\n      </div>\n      <div>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          width={width}\n          height={height}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Canvas;\n","import React from 'react';\nimport './App.css';\nimport Canvas from './canvas';\n\nconst App: React.FC = () => {\n\n \n\n  return (\n    <div className=\"container\">\n   <div>\n     <h1 className=\"header\">Maze Generator</h1>\n   </div >\n    <Canvas />\n   </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}