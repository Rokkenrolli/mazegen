{"version":3,"sources":["utils.ts","render.ts","generator.ts","solver.ts","canvas.tsx","App.tsx","index.tsx"],"names":["Direction","render","context","board","blockWidth","blockHeight","draw","block","color","sizeOffset","offset","fillStyle","fillRect","pos","x","y","forEach","col","e","start","end","next","onPath","solved","visited","topLeft","botLeft","topRight","botRight","drawLine","beginPath","moveTo","lineTo","strokeStyle","stroke","bottomWall","leftWall","rightWall","topWall","drawWalls","lines","pred","predPos","drawConnecting","neighbours","cols","rows","solving","row","all","push","length","filter","determineDir","first","second","rowDif","colDif","Down","Up","Right","Left","generator","path","current","undefined","window","requestAnimationFrame","step","neighbors","Math","floor","random","dir","breakWall","pop","clearRect","width","height","solver","correctPath","found","shift","console","log","cPath","generateCorrectPath","r","n","available","b","filterAvailable","innerWidth","innerHeight","Canvas","canvasRef","useRef","useState","setRows","setCols","setBlockWidth","setBlockHeight","initalize","temp","useEffect","getContext","className","onClick","generate","solve","setLines","id","type","min","onChange","event","Number","target","value","htmlFor","ref","App","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.1e5e9595.chunk.js","sourcesContent":["import render, { Block, } from \"./render\"\r\n\r\nexport enum Direction {\r\n    Up = 1,\r\n    Down,\r\n    Left,\r\n    Right,\r\n}   \r\n\r\nconst neighbours = (board:Block[][],block:Block,cols:number,rows:number, solving?:boolean):Block[] => {\r\n    const row = block.row\r\n    const col = block.col\r\n    let all:Block[] = []\r\n    if (row > 0 ) all.push(board[col][row -1])\r\n    if (col > 0 ) all.push(board[col -1][row])\r\n    if (row < rows -1) all.push(board[col][row +1])\r\n    if (col < cols -1) all.push(board[col+1][row])\r\n    if (all.length === 0) return []\r\n    else {\r\n        const filtered = all.filter(x=>solving? !x.solved: !x.visited)\r\n        return filtered\r\n    }\r\n}\r\n\r\n\r\n\r\n//determines the direction of the second block in relation of the first block\r\nconst determineDir = (first:Block, second:Block) => {\r\n    \r\n    const rowDif = first.row - second.row\r\n    const colDif = first.col - second.col\r\n\r\n    if (rowDif < 0)  return Direction.Down \r\n    if (rowDif > 0)  return Direction.Up\r\n    if (colDif < 0)  return Direction.Right\r\n    if (colDif > 0)  return Direction.Left\r\n\r\n   \r\n}\r\n\r\nconst filterAvailable = (current:Block, neighbours: Block[]) => {\r\n    return neighbours.filter(b => {\r\n        const directionFromCurrent = determineDir(current, b)\r\n        switch (directionFromCurrent) {\r\n            case Direction.Up:\r\n                return !(current.topWall && b.bottomWall)\r\n            case Direction.Down:\r\n                return !(current.bottomWall && b.topWall)\r\n            case Direction.Left:\r\n                return !(current.leftWall && b.rightWall)\r\n            case Direction.Right:\r\n                return !(current.rightWall && b.leftWall)\r\n        }\r\n        return false\r\n    })\r\n}\r\n\r\nconst generateCorrectPath = (context:CanvasRenderingContext2D,board: Block[][],cPath:Block[],cols:number, rows:number, blockWidth:number, blockHeight: number) => {\r\n    \r\n    cPath = [];\r\n    let current = board[cols - 1][rows - 1];\r\n    const step = () =>  {\r\n        if (current.pred) {\r\n            window.requestAnimationFrame(step)\r\n            cPath.push(current);\r\n            current.onPath = true\r\n            current = current.pred;\r\n        }\r\n        render(context, board, blockWidth, blockHeight);\r\n     \r\n    }\r\n   \r\n    cPath.push(board[0][0]);\r\n    board[0][0].onPath = true\r\n    window.requestAnimationFrame(step)\r\n    \r\n  };\r\n\r\nexport {neighbours, determineDir, filterAvailable, generateCorrectPath}","\nimport {lines} from \"./canvas\"\n\n\nexport type Coord = {\n    x: number\n    y: number\n}\n\n\n\nexport type Block = {\n    leftWall:boolean\n    topWall: boolean\n    rightWall:boolean\n    bottomWall:boolean\n    pos: Coord\n    visited:boolean\n    row:number\n    col:number\n    next: boolean\n    pred: Block | undefined\n    start:boolean\n    end:boolean\n    solved:boolean\n    onPath: boolean\n}\n\n\n\nconst render = (context:CanvasRenderingContext2D, board: Block[][], blockWidth:number, blockHeight:number) => {\n  \n    \n    const draw = (block:Block, color:string,sizeOffset?:number) => {\n        const offset = sizeOffset ?sizeOffset : 0\n        context.fillStyle= color\n        context.fillRect(block.pos.x,block.pos.y,blockWidth- offset,blockHeight- offset)\n        \n    }\n\n    \n    \n    \n\n    const drawWalls = (block:Block) => {\n\n        const topLeft  = {x:block.pos.x, y:block.pos.y}\n        const botLeft  = {x:block.pos.x, y:block.pos.y + blockHeight}\n        const topRight = {x:block.pos.x + blockWidth, y:block.pos.y}\n        const botRight = {x:block.pos.x + blockWidth, y:block.pos.y + blockHeight}\n        \n\n        const drawLine = (start:Coord,end:Coord) => {\n            context.beginPath()\n            context.moveTo(start.x,start.y)\n            context.lineTo(end.x,end.y)\n            context.strokeStyle = \"black\"\n            context.stroke()\n        }\n        \n        if (block.bottomWall) drawLine(botLeft, botRight)\n        if (block.leftWall)   drawLine(topLeft, botLeft)\n        if (block.rightWall)  drawLine(topRight,botRight)\n        if (block.topWall)    drawLine(topLeft, topRight)\n       \n    }\n\n    \n\n    const drawConnecting = (block: Block) => {\n        const pos:Coord = {x: block.pos.x + blockWidth / 2, y:block.pos.y+blockHeight /2}\n        if (block.pred) {\n            const predPos:Coord = {x:block.pred.pos.x + blockWidth /2, y:block.pred.pos.y + blockHeight / 2}\n            context.beginPath()\n            context.strokeStyle = \"green\"\n            context.moveTo(pos.x,pos.y)\n            context.lineTo(predPos.x,predPos.y)\n            context.stroke()\n        }\n    }\n\n\n    board.forEach(col => col.forEach(e =>{\n        if(e.start || e.end) draw(e,\"orange\")\n        else if (e.next) draw(e,\"blue\")\n        else if (e.onPath) draw(e, \"#85bbb6\")\n        else if(e.solved) draw(e, \"#8abb85\")\n        else if(e.visited) draw(e,\"white\")\n        else draw(e,\"#b678bd\") \n        drawWalls(e)\n        if (lines) drawConnecting(e)\n        \n    } ) )\n    \n}\n\nexport default render","import { Block } from \"./render\"\nimport {  height, width } from \"./canvas\"\nimport {neighbours, determineDir, Direction} from \"./utils\"\nimport render from \"./render\"\n\n\n\n\n\n\nconst generator = (context:CanvasRenderingContext2D, board:Block[][],  cols:number, rows:number, blockWidth:number, blockHeight: number) => {\n    const path:Block[]  = [board[0][0]]\n\nconst breakWall = (start: Block,end:Block) => {\n\n    const dir = determineDir(start,end)\n    if (dir === Direction.Up) {\n        start.topWall = false\n        end.bottomWall = false\n    }\n\n    if (dir === Direction.Down) {\n        start.bottomWall = false\n        end.topWall      = false \n    }\n\n    if (dir === Direction.Left) {\n        start.leftWall = false\n        end.rightWall = false\n    }\n\n    if (dir === Direction.Right) {\n        start.rightWall = false\n        end.leftWall = false\n    }\n    \n}\n\n  \n  let current:Block | undefined = board[0][0]\n  let next:Block | undefined  = undefined\n\n/**\n * step is a single step of depth-first search algorithm,\n * which is rendered on a canvas\n */\n\n  const step = () => { \n\n  if (path.length) {\n    window.requestAnimationFrame(step)\n    if (!current) return\n    current.next = false\n    current.visited = true\n    const neighbors = neighbours(board,current,cols, rows)\n    if (neighbors.length) {\n        next= neighbors[Math.floor(Math.random()*neighbors.length)]; //pick a random next neighbor\n        next.pred = current\n        next.next = true\n         breakWall(current,next)\n         path.push(current = next)\n    }\n\n    else {\n            current = path.pop()\n    }\n\n  }\n  context.clearRect(0,0,width,height)\n  render(context,board,blockWidth, blockHeight)\n  }\n  \nwindow.requestAnimationFrame(step)\n}\n\nexport default generator","\r\nimport { height, width } from \"./canvas\"\r\nimport render, { Block } from \"./render\"\r\nimport { neighbours, filterAvailable, generateCorrectPath } from \"./utils\"\r\n\r\n\r\nconst solver = (context:CanvasRenderingContext2D,board: Block[][],correctPath: Block[],cols:number, rows:number, blockWidth:number, blockHeight: number) => {\r\n    const path:Block[]  = [board[0][0]] //start from the first block - set start\r\n    let found = false\r\n\r\n    const step = () => { \r\n        if (path.length) {\r\n\r\n            if (!found) {\r\n\r\n                window.requestAnimationFrame(step)\r\n            }\r\n            const current = path.shift()\r\n            console.log(current)\r\n            if (!current) {\r\n                return false\r\n            }\r\n            current.solved = true\r\n            if (current.end) {\r\n                found = true\r\n                generateCorrectPath(context, board, correctPath, cols, rows, blockWidth, blockHeight)\r\n                board.forEach(e => e.forEach(r => r.solved = false))\r\n                return current\r\n            }\r\n            console.log(board)\r\n            const n = neighbours(board, current,cols,rows, true)\r\n            console.log(n)\r\n            const available = filterAvailable(current,n)\r\n            console.log(available)\r\n            available.forEach(e => {\r\n                if (!e.solved) {\r\n                    path.push(e)\r\n                }\r\n            })\r\n        }\r\n        \r\n        context.clearRect(0,0,width,height)\r\n        render(context,board,blockWidth, blockHeight)\r\n        }\r\n        \r\n      window.requestAnimationFrame(step)\r\n      \r\n      \r\n      }\r\n\r\n\r\n\r\nexport  {solver}","import React, { useRef, useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport render, { Block } from \"./render\";\nimport generator from \"./generator\";\nimport { solver } from \"./solver\";\n\nexport const width = window.innerWidth * 0.8;\nexport const height = window.innerHeight * 0.8;\n\nexport let lines = false;\n\nconst Canvas = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [rows, setRows] = useState(20);\n  const [cols, setCols] = useState(40);\n  const [blockWidth, setBlockWidth] = useState(width / cols);\n  const [blockHeight, setBlockHeight] = useState(height / rows);\n\n  let cPath: Block[] = [];\n  let board: Block[][] = [];\n  let generating: boolean = false;\n  const generate = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    initalize(context);\n    generator(context, board, cols, rows, blockWidth, blockHeight);\n  };\n\n  const solve = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    if (generating) {\n      alert(\"Maze is being generated\");\n      return;\n    }\n    solver(context, board, cPath, cols, rows, blockWidth, blockHeight);\n  };\n\n  const setLines = () => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    lines = !lines;\n    render(context, board, blockWidth, blockHeight);\n  };\n\n  const initalize = (context: CanvasRenderingContext2D) => {\n    board = [];\n    context.clearRect(0, 0, width, height);\n\n    for (let col = 0; col < cols; col++) {\n      const temp: Block[] = [];\n      for (let row = 0; row < rows; row++)\n        temp.push({\n          leftWall: true,\n          topWall: true,\n          rightWall: true,\n          bottomWall: true,\n          pos: { x: col * blockWidth, y: row * blockHeight },\n          visited: false,\n          row: row,\n          col: col,\n          next: false,\n          pred: undefined,\n          start: false,\n          end: false,\n          solved: false,\n          onPath: false,\n        });\n      board.push(temp);\n    }\n    const start = board[0][0];\n    start.start = true;\n    start.topWall = false;\n    start.visited = true;\n    board[cols - 1][rows - 1].end = true;\n    board[cols - 1][rows - 1].bottomWall = false;\n    render(context, board, blockWidth, blockHeight);\n  };\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const context = canvasRef.current.getContext(\"2d\");\n    if (!context) return;\n    initalize(context);\n  });\n\n  return (\n    <div className=\"canvasContainer\">\n      <div className=\"buttons\">\n        <button className=\"generator\" onClick={() => generate()}>\n          Generate Maze\n        </button>\n        <button className=\"solver\" onClick={() => solve()}>\n          Solve maze\n        </button>\n        <button className=\"lines\" onClick={() => setLines()}>\n          Show lines\n        </button>\n      </div>\n      <div className=\"sliders\">\n        <input\n          id=\"colSlider\"\n          type=\"range\"\n          min={1}\n          onChange={(event) => {\n            setCols(Number(event.target.value));\n            setBlockHeight(height / rows);\n            setBlockWidth(width / cols);\n          }}\n          value={cols}\n          step={1}\n        ></input>\n        <label htmlFor=\"colSlider\">{`columns: ${cols}`}</label>\n        <input\n          id=\"rowSlider\"\n          type=\"range\"\n          min={1}\n          onChange={(event) => {\n            setRows(Number(event.target.value));\n            setBlockHeight(height / rows);\n            setBlockWidth(width / cols);\n          }}\n          value={rows}\n          step={1}\n        ></input>\n        <label htmlFor=\"rowSlider\">{`rows: ${rows}`}</label>\n      </div>\n      <div>\n        <canvas\n          ref={canvasRef}\n          className=\"canvas\"\n          width={width}\n          height={height}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Canvas;\n","import React from 'react';\nimport './App.css';\nimport Canvas from './canvas';\n\nconst App: React.FC = () => {\n\n \n\n  return (\n    <div className=\"container\">\n   <div>\n     <h1 className=\"header\">Maze Generator</h1>\n   </div >\n    <Canvas />\n   </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}